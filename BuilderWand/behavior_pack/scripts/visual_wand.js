import { world, system, Player, ItemStack, BlockPermutation } from '@minecraft/server';

// Sistema de Varinha com Part√≠cula √önica na Dire√ß√£o do Olhar
class SingleParticleWand {
    constructor() {
        this.playerCooldowns = new Map();
        this.playerRanges = new Map();
        this.initialize();
    }

    initialize() {
        try {
            world.sendMessage("¬ße[Single Wand] Iniciando sistema de part√≠cula √∫nica...");
            
            system.runTimeout(() => {
                this.setupEvents();
                this.startDirectionDetection();
                world.sendMessage("¬ßa[Single Wand] Sistema ativo! Segure graveto e olhe para faces de blocos!");
                world.sendMessage("¬ß8Uma part√≠cula aparece na dire√ß√£o que voc√™ olha | Clique direito para construir");
            }, 20);
            
        } catch (error) {
            world.sendMessage(`¬ßc[Single Wand] Erro: ${error}`);
        }
    }

    setupEvents() {
        try {
            // Evento de clique direito - construir na dire√ß√£o atual
            if (world.afterEvents && world.afterEvents.itemUse) {
                world.afterEvents.itemUse.subscribe((event) => {
                    try {
                        const { source: player, itemStack } = event;
                        
                        if (!player || !itemStack || itemStack.typeId !== 'minecraft:stick') return;
                        
                        // Detectar dire√ß√£o atual que est√° olhando
                        const currentDirection = this.getCurrentDirection(player);
                        if (currentDirection) {
                            this.buildInDirection(player, currentDirection);
                        } else {
                            player.sendMessage("¬ßc‚ùå Mire em um bloco para construir!");
                        }
                        
                    } catch (error) {
                        world.sendMessage(`¬ßc[Single Wand] Erro no clique: ${error}`);
                    }
                });
            }

            // Comandos
            if (world.beforeEvents && world.beforeEvents.chatSend) {
                world.beforeEvents.chatSend.subscribe((event) => {
                    try {
                        const message = event.message.toLowerCase();
                        
                        if (message === "!wand-help") {
                            event.cancel = true;
                            this.showHelp(event.sender);
                        }
                        
                        if (message.startsWith("!range ")) {
                            event.cancel = true;
                            const rangeStr = message.split(" ")[1];
                            const range = parseInt(rangeStr);
                            
                            if (isNaN(range) || range < 1 || range > 20) {
                                event.sender.sendMessage("¬ßc‚ùå Use valores entre 1 e 20!");
                                return;
                            }
                            
                            this.playerRanges.set(event.sender.name, range);
                            event.sender.sendMessage(`¬ßa‚úÖ Dist√¢ncia: ¬ße${range} blocos¬ßa!`);
                        }
                        
                    } catch (error) {
                        world.sendMessage(`¬ßc[Single Wand] Erro no comando: ${error}`);
                    }
                });
            }

        } catch (error) {
            world.sendMessage(`¬ßc[Single Wand] Erro ao configurar eventos: ${error}`);
        }
    }

    // Sistema principal - detectar dire√ß√£o que o jogador est√° olhando
    startDirectionDetection() {
        system.runInterval(() => {
            try {
                for (const player of world.getPlayers()) {
                    if (!player.isValid()) continue;
                    
                    // Verificar se est√° segurando graveto
                    const heldItem = player.getComponent('minecraft:equippable')?.getEquipment('Mainhand');
                    if (!heldItem || heldItem.typeId !== 'minecraft:stick') {
                        continue;
                    }
                    
                    // Mostrar part√≠cula na dire√ß√£o atual
                    this.showCurrentDirectionParticle(player);
                }
            } catch (error) {
                // Silencioso para n√£o spammar
            }
        }, 2); // Verificar mais frequentemente para suavidade
    }

    showCurrentDirectionParticle(player) {
        try {
            // Detectar bloco e face que est√° olhando
            const blockRaycast = player.getBlockFromViewDirection({ maxDistance: 6 });
            if (!blockRaycast || !blockRaycast.block) return;

            const block = blockRaycast.block;
            const face = blockRaycast.face;
            
            // Calcular dire√ß√£o baseada na face e posi√ß√£o do olhar
            const direction = this.calculateDirectionFromLook(player, block, face);
            if (!direction) return;

            // Mostrar part√≠cula na posi√ß√£o calculada
            const particlePos = this.getParticlePosition(block.location, face, direction);
            
            // Usar m√∫ltiplas part√≠culas para melhor visibilidade
            player.dimension.spawnParticle('minecraft:villager_happy', {
                x: particlePos.x,
                y: particlePos.y + 0.8,
                z: particlePos.z
            });
            
        } catch (error) {
            // Ignorar erros de part√≠culas
        }
    }

    calculateDirectionFromLook(player, block, face) {
        try {
            // Obter dire√ß√£o do olhar do jogador
            const viewDirection = player.getViewDirection();
            const blockCenter = {
                x: block.location.x + 0.5,
                y: block.location.y + 0.5,
                z: block.location.z + 0.5
            };
            
            // Calcular onde o olhar intersecta com a face do bloco
            const intersection = this.calculateFaceIntersection(player.location, viewDirection, blockCenter, face);
            if (!intersection) return null;

            // Converter posi√ß√£o na face para dire√ß√£o de constru√ß√£o
            return this.facePositionToDirection(intersection, face);
            
        } catch (error) {
            return null;
        }
    }

    calculateFaceIntersection(playerPos, viewDir, blockCenter, face) {
        // Calcular onde o raio do olhar intersecta com a face do bloco
        const faceNormal = this.getFaceNormal(face);
        const faceCenter = {
            x: blockCenter.x + faceNormal.x * 0.5,
            y: blockCenter.y + faceNormal.y * 0.5,
            z: blockCenter.z + faceNormal.z * 0.5
        };

        // Calcular interse√ß√£o do raio com o plano da face
        const eyePos = {
            x: playerPos.x,
            y: playerPos.y + 1.6, // Altura dos olhos
            z: playerPos.z
        };

        // Produto escalar para encontrar interse√ß√£o
        const denominator = 
            viewDir.x * faceNormal.x + 
            viewDir.y * faceNormal.y + 
            viewDir.z * faceNormal.z;

        if (Math.abs(denominator) < 0.0001) return null; // Paralelo √† face

        const t = (
            (faceCenter.x - eyePos.x) * faceNormal.x +
            (faceCenter.y - eyePos.y) * faceNormal.y +
            (faceCenter.z - eyePos.z) * faceNormal.z
        ) / denominator;

        if (t < 0) return null; // Atr√°s do jogador

        // Ponto de interse√ß√£o
        const intersection = {
            x: eyePos.x + viewDir.x * t,
            y: eyePos.y + viewDir.y * t,
            z: eyePos.z + viewDir.z * t
        };

        return intersection;
    }

    getFaceNormal(face) {
        const normals = {
            'North': { x: 0, y: 0, z: -1 },
            'South': { x: 0, y: 0, z: 1 },
            'East': { x: 1, y: 0, z: 0 },
            'West': { x: -1, y: 0, z: 0 },
            'Up': { x: 0, y: 1, z: 0 },
            'Down': { x: 0, y: -1, z: 0 }
        };
        return normals[face] || { x: 0, y: 0, z: 0 };
    }

    facePositionToDirection(intersection, face) {
        // SIMPLIFICADO: Usar apenas a dire√ß√£o perpendicular √† face
        // Isso evita constru√ß√µes diagonais/escadinha indesejadas
        switch (face) {
            case 'North':
                return { x: 0, y: 0, z: -1, name: '‚¨Ü Norte' };
            case 'South':
                return { x: 0, y: 0, z: 1, name: '‚¨á Sul' };
            case 'East':
                return { x: 1, y: 0, z: 0, name: '‚û° Leste' };
            case 'West':
                return { x: -1, y: 0, z: 0, name: '‚¨Ö Oeste' };
            case 'Up':
                return { x: 0, y: 1, z: 0, name: '‚¨Ü Cima' };
            case 'Down':
                return { x: 0, y: 0, z: 0, name: 'üîΩ Baixo (Horizontal)' };
            default:
                return null;
        }
    }

    getDirectionFromFacePosition(u, v, faceType) {
        // Dividir a face em 9 regi√µes (3x3)
        const regionU = u < 0.33 ? 0 : (u < 0.67 ? 1 : 2);
        const regionV = v < 0.33 ? 0 : (v < 0.67 ? 1 : 2);
        
        // Mapear regi√£o para dire√ß√£o baseada no tipo de face
        const directionMap = {
            'north': [
                [{ x: -1, y: -1, z: -1, name: '‚Üô Sudoeste-Baixo' }, { x: 0, y: -1, z: -1, name: '‚¨á Sul-Baixo' }, { x: 1, y: -1, z: -1, name: '‚Üò Sudeste-Baixo' }],
                [{ x: -1, y: 0, z: -1, name: '‚¨Ö Oeste' }, { x: 0, y: 0, z: -1, name: '‚¨Ü Norte' }, { x: 1, y: 0, z: -1, name: '‚û° Leste' }],
                [{ x: -1, y: 1, z: -1, name: '‚Üñ Noroeste-Cima' }, { x: 0, y: 1, z: -1, name: '‚¨Ü Norte-Cima' }, { x: 1, y: 1, z: -1, name: '‚Üó Nordeste-Cima' }]
            ],
            'south': [
                [{ x: 1, y: -1, z: 1, name: '‚Üô Sudoeste-Baixo' }, { x: 0, y: -1, z: 1, name: '‚¨á Sul-Baixo' }, { x: -1, y: -1, z: 1, name: '‚Üò Sudeste-Baixo' }],
                [{ x: 1, y: 0, z: 1, name: '‚¨Ö Oeste' }, { x: 0, y: 0, z: 1, name: '‚¨á Sul' }, { x: -1, y: 0, z: 1, name: '‚û° Leste' }],
                [{ x: 1, y: 1, z: 1, name: '‚Üñ Noroeste-Cima' }, { x: 0, y: 1, z: 1, name: '‚¨Ü Sul-Cima' }, { x: -1, y: 1, z: 1, name: '‚Üó Nordeste-Cima' }]
            ],
            'east': [
                [{ x: 1, y: -1, z: 1, name: '‚Üô Sul-Baixo' }, { x: 1, y: -1, z: 0, name: '‚¨á Baixo' }, { x: 1, y: -1, z: -1, name: '‚Üò Norte-Baixo' }],
                [{ x: 1, y: 0, z: 1, name: '‚¨Ö Sul' }, { x: 1, y: 0, z: 0, name: '‚û° Leste' }, { x: 1, y: 0, z: -1, name: '‚û° Norte' }],
                [{ x: 1, y: 1, z: 1, name: '‚Üñ Sul-Cima' }, { x: 1, y: 1, z: 0, name: '‚¨Ü Cima' }, { x: 1, y: 1, z: -1, name: '‚Üó Norte-Cima' }]
            ],
            'west': [
                [{ x: -1, y: -1, z: -1, name: '‚Üô Sul-Baixo' }, { x: -1, y: -1, z: 0, name: '‚¨á Baixo' }, { x: -1, y: -1, z: 1, name: '‚Üò Norte-Baixo' }],
                [{ x: -1, y: 0, z: -1, name: '‚¨Ö Sul' }, { x: -1, y: 0, z: 0, name: '‚¨Ö Oeste' }, { x: -1, y: 0, z: 1, name: '‚û° Norte' }],
                [{ x: -1, y: 1, z: -1, name: '‚Üñ Sul-Cima' }, { x: -1, y: 1, z: 0, name: '‚¨Ü Cima' }, { x: -1, y: 1, z: 1, name: '‚Üó Norte-Cima' }]
            ],
            'up': [
                [{ x: -1, y: 1, z: 1, name: '‚Üô Sudoeste' }, { x: 0, y: 1, z: 1, name: '‚¨á Sul' }, { x: 1, y: 1, z: 1, name: '‚Üò Sudeste' }],
                [{ x: -1, y: 1, z: 0, name: '‚¨Ö Oeste' }, { x: 0, y: 1, z: 0, name: '‚¨Ü Cima' }, { x: 1, y: 1, z: 0, name: '‚û° Leste' }],
                [{ x: -1, y: 1, z: -1, name: '‚Üñ Noroeste' }, { x: 0, y: 1, z: -1, name: '‚¨Ü Norte' }, { x: 1, y: 1, z: -1, name: '‚Üó Nordeste' }]
            ],
            'down': [
                [{ x: -1, y: -1, z: -1, name: '‚Üô Noroeste' }, { x: 0, y: -1, z: -1, name: '‚¨Ü Norte' }, { x: 1, y: -1, z: -1, name: '‚Üó Nordeste' }],
                [{ x: -1, y: -1, z: 0, name: '‚¨Ö Oeste' }, { x: 0, y: -1, z: 0, name: '‚¨á Baixo' }, { x: 1, y: -1, z: 0, name: '‚û° Leste' }],
                [{ x: -1, y: -1, z: 1, name: '‚Üñ Sudoeste' }, { x: 0, y: -1, z: 1, name: '‚¨á Sul' }, { x: 1, y: -1, z: 1, name: '‚Üò Sudeste' }]
            ]
        };

        return directionMap[faceType]?.[regionV]?.[regionU] || null;
    }

    getParticlePosition(blockLocation, face, direction) {
        // Posi√ß√£o base da face
        const faceOffset = this.getFaceOffset(face);
        const basePos = {
            x: blockLocation.x + 0.5 + faceOffset.x,
            y: blockLocation.y + 0.5 + faceOffset.y,
            z: blockLocation.z + 0.5 + faceOffset.z
        };

        // Offset adicional baseado na dire√ß√£o (para mostrar onde vai construir)
        const directionOffset = 0.2;
        
        return {
            x: basePos.x + (direction.x * directionOffset * 0.3),
            y: basePos.y + (direction.y * directionOffset * 0.3),
            z: basePos.z + (direction.z * directionOffset * 0.3)
        };
    }

    getFaceOffset(face) {
        // Offset para colar a part√≠cula na face
        const offset = 0.05;
        const offsets = {
            'North': { x: 0, y: 0, z: -offset },
            'South': { x: 0, y: 0, z: offset },
            'East': { x: offset, y: 0, z: 0 },
            'West': { x: -offset, y: 0, z: 0 },
            'Up': { x: 0, y: offset, z: 0 },
            'Down': { x: 0, y: -offset, z: 0 }
        };
        return offsets[face] || { x: 0, y: 0, z: 0 };
    }

    getCurrentDirection(player) {
        try {
            const blockRaycast = player.getBlockFromViewDirection({ maxDistance: 6 });
            if (!blockRaycast || !blockRaycast.block) return null;

            const block = blockRaycast.block;
            const face = blockRaycast.face;
            
            return this.calculateDirectionFromLook(player, block, face);
        } catch (error) {
            return null;
        }
    }

    buildInDirection(player, direction) {
        try {
            // Verificar cooldown
            const now = Date.now();
            const lastUse = this.playerCooldowns.get(player.name) || 0;
            if (now - lastUse < 500) return;
            
            this.playerCooldowns.set(player.name, now);
            
            const range = this.playerRanges.get(player.name) || 5;
            const buildBlock = this.getBuildBlock(player);
            
            if (!buildBlock) {
                player.sendMessage("¬ßc‚ùå Voc√™ precisa ter blocos no invent√°rio!");
                return;
            }

            // Obter bloco base
            const blockRaycast = player.getBlockFromViewDirection({ maxDistance: 6 });
            if (!blockRaycast || !blockRaycast.block) {
                player.sendMessage("¬ßc‚ùå Aponte para um bloco v√°lido para construir!");
                return;
            }

            const face = blockRaycast.face;
            
            // üîß CORRE√á√ÉO: Se estiver olhando para baixo, anula constru√ß√£o vertical
            if (face === 'Down') {
                direction.y = 0;
                world.sendMessage(`¬ß8[DEBUG] Face Down detectada - for√ßando Y=0`);
            }
            world.sendMessage(`¬ße[DEBUG] Construindo na dire√ß√£o: ${direction.name}`);
            // Debug melhorado
            world.sendMessage(`¬ße[DEBUG] Face detectada: ${face}`);
            world.sendMessage(`¬ß8[DEBUG] Dire√ß√£o original: (${direction.x}, ${direction.y}, ${direction.z}) - ${direction.name}`);
            
            // Construir blocos
            const blocksPlaced = this.buildBlocks(player, blockRaycast.block.location, direction, buildBlock, range);
            
            if (blocksPlaced > 0) {
                player.sendMessage(`¬ßa‚úÖ ${blocksPlaced} blocos colocados na dire√ß√£o ${direction.name}!`);
                this.consumeBlocks(player, buildBlock, blocksPlaced);
            } else {
                player.sendMessage("¬ßc‚ùå Nenhum bloco foi colocado! Verifique se h√° espa√ßo livre.");
            }
            
        } catch (error) {
            world.sendMessage(`¬ßc[Single Wand] Erro na constru√ß√£o: ${error}`);
        }
    }

    buildBlocks(player, startLocation, direction, blockType, range) {
        let blocksPlaced = 0;
        
        // Debug da constru√ß√£o
        world.sendMessage(`¬ße[DEBUG] Iniciando constru√ß√£o:`);
        world.sendMessage(`¬ß8- Posi√ß√£o inicial: (${startLocation.x}, ${startLocation.y}, ${startLocation.z})`);
        world.sendMessage(`¬ß8- Dire√ß√£o: (${direction.x}, ${direction.y}, ${direction.z})`);
        world.sendMessage(`¬ß8- Alcance: ${range} blocos`);
        
        for (let i = 1; i <= range; i++) {
            // CORRE√á√ÉO: Construir em linha reta, n√£o em escadinha
            const buildPos = {
                x: Math.floor(startLocation.x + (direction.x * i)),
                y: Math.floor(startLocation.y + (direction.y * i)),
                z: Math.floor(startLocation.z + (direction.z * i))
            };
            
            world.sendMessage(`¬ß8[DEBUG] Bloco ${i}: tentando posi√ß√£o (${buildPos.x}, ${buildPos.y}, ${buildPos.z})`);
            
            try {
                const buildBlock = player.dimension.getBlock(buildPos);
                if (!buildBlock) {
                    world.sendMessage(`¬ßc[DEBUG] Bloco ${i}: posi√ß√£o inv√°lida`);
                    continue;
                }
                
                // Verificar se o espa√ßo est√° livre
                if (buildBlock.typeId !== 'minecraft:air') {
                    world.sendMessage(`¬ßc[DEBUG] Bloco ${i}: espa√ßo ocupado por ${buildBlock.typeId}`);
                    continue;
                }
                
                // Colocar bloco
                buildBlock.setPermutation(BlockPermutation.resolve(blockType));
                blocksPlaced++;
                world.sendMessage(`¬ßa[DEBUG] Bloco ${i}: colocado com sucesso!`);
                
                // Part√≠cula de sucesso
                const particlePos = {
                    x: buildPos.x + 0.5,
                    y: buildPos.y + 0.5,
                    z: buildPos.z + 0.5
                };
                player.dimension.spawnParticle('minecraft:villager_happy', particlePos);
                
            } catch (error) {
                world.sendMessage(`¬ßc[DEBUG] Erro no bloco ${i} na posi√ß√£o (${buildPos.x}, ${buildPos.y}, ${buildPos.z}): ${error}`);
            }
        }
        
        world.sendMessage(`¬ße[DEBUG] Constru√ß√£o finalizada: ${blocksPlaced} blocos colocados`);
        return blocksPlaced;
    }

    getBuildBlock(player) {
        try {
            const inventory = player.getComponent('minecraft:inventory');
            if (!inventory) return null;
            
            const container = inventory.container;
            if (!container) return null;
            
            for (let i = 0; i < container.size; i++) {
                try {
                    const item = container.getItem(i);
                    if (item && item.typeId !== 'minecraft:stick' && this.isPlaceableBlock(item.typeId)) {
                        world.sendMessage(`¬ßa[DEBUG] Bloco encontrado: ${item.typeId} (quantidade: ${item.amount})`);
                        return item.typeId;
                    }
                } catch (error) {
                    // Ignorar slots com erro
                    continue;
                }
            }
            
            world.sendMessage(`¬ßc[DEBUG] Nenhum bloco v√°lido encontrado no invent√°rio`);
            return null;
        } catch (error) {
            world.sendMessage(`¬ßc[DEBUG] Erro ao acessar invent√°rio: ${error}`);
            return null;
        }
    }

    consumeBlocks(player, blockType, amount) {
        try {
            const inventory = player.getComponent('minecraft:inventory');
            if (!inventory) {
                world.sendMessage(`¬ßc[DEBUG] Invent√°rio n√£o encontrado`);
                return;
            }
            
            const container = inventory.container;
            if (!container) {
                world.sendMessage(`¬ßc[DEBUG] Container n√£o encontrado`);
                return;
            }
            
            let remaining = amount;
            let consumed = 0;
            
            for (let i = 0; i < container.size && remaining > 0; i++) {
                try {
                    const item = container.getItem(i);
                    if (item && item.typeId === blockType) {
                        const consumeAmount = Math.min(remaining, item.amount);
                        remaining -= consumeAmount;
                        consumed += consumeAmount;
                        
                        if (consumeAmount >= item.amount) {
                            container.setItem(i, undefined);
                        } else {
                            const newItem = item.clone();
                            newItem.amount -= consumeAmount;
                            container.setItem(i, newItem);
                        }
                    }
                } catch (error) {
                    // Ignorar slots com erro
                    continue;
                }
            }
            
            world.sendMessage(`¬ßa[DEBUG] Consumidos ${consumed} blocos do tipo ${blockType}`);
        } catch (error) {
            world.sendMessage(`¬ßc[Single Wand] Erro ao consumir blocos: ${error}`);
        }
    }

    isPlaceableBlock(itemType) {
        const placeableBlocks = [
            'minecraft:stone', 'minecraft:dirt', 'minecraft:grass_block',
            'minecraft:cobblestone', 'minecraft:oak_planks', 'minecraft:spruce_planks',
            'minecraft:birch_planks', 'minecraft:jungle_planks', 'minecraft:acacia_planks',
            'minecraft:dark_oak_planks', 'minecraft:bricks', 'minecraft:stone_bricks',
            'minecraft:white_concrete', 'minecraft:black_concrete', 'minecraft:red_concrete',
            'minecraft:blue_concrete', 'minecraft:green_concrete', 'minecraft:yellow_concrete',
            'minecraft:orange_concrete', 'minecraft:purple_concrete', 'minecraft:pink_concrete',
            'minecraft:lime_concrete', 'minecraft:cyan_concrete', 'minecraft:light_blue_concrete',
            'minecraft:magenta_concrete', 'minecraft:brown_concrete', 'minecraft:light_gray_concrete',
            'minecraft:gray_concrete', 'minecraft:sandstone', 'minecraft:red_sandstone', 'minecraft:glass',
            'minecraft:oak_log', 'minecraft:spruce_log', 'minecraft:birch_log',
            'minecraft:jungle_log', 'minecraft:acacia_log', 'minecraft:dark_oak_log',
            'minecraft:netherrack', 'minecraft:end_stone', 'minecraft:quartz_block',
            'minecraft:iron_block', 'minecraft:gold_block', 'minecraft:diamond_block',
            'minecraft:emerald_block', 'minecraft:coal_block', 'minecraft:redstone_block',
            'minecraft:lapis_block', 'minecraft:wool', 'minecraft:terracotta'
        ];
        
        return placeableBlocks.includes(itemType);
    }

    showHelp(player) {
        const currentRange = this.playerRanges.get(player.name) || 5;
        
        const helpText = `¬ß6¬ßl=== ü™Ñ VARINHA ULTRA SIMPLES ===

¬ßf¬ßlüìã Como usar:
¬ß81. Pegue um ¬ßeGraveto ¬ß8(sua varinha)
¬ß82. Tenha blocos no invent√°rio
¬ß83. Segure o graveto e clique direito em um bloco
¬ß84. 5 blocos ser√£o colocados na dire√ß√£o da face clicada

¬ßf¬ßl‚ú® Funcionalidades:
¬ß8‚Ä¢ ¬ßaPart√≠culas ¬ß8mostram onde voc√™ clicou
¬ß8‚Ä¢ ¬ßbConstru√ß√£o autom√°tica ¬ß8de 5 blocos
¬ß8‚Ä¢ ¬ßeConsome blocos ¬ß8do seu invent√°rio
¬ß8‚Ä¢ ¬ßdCooldown ¬ß8de 0.5 segundos

¬ßf¬ßlüí° Dicas:
¬ß8‚Ä¢ Funciona com qualquer bloco s√≥lido
¬ß8‚Ä¢ Clique na face do bloco para escolher dire√ß√£o
¬ß8‚Ä¢ Use ¬ßf!wand-help ¬ß8para ver esta ajuda

¬ßf¬ßl‚öôÔ∏è Configura√ß√£o atual:
¬ß8‚Ä¢ Dist√¢ncia: ¬ße${currentRange} blocos

¬ßf¬ßlüéØ Comandos:
¬ß8‚Ä¢ ¬ßf!range [1-20] ¬ß8- Definir dist√¢ncia`;

        player.sendMessage(helpText);
    }
}

// Inicializar sistema
world.sendMessage("¬ße[Single Wand] Carregando sistema de part√≠cula √∫nica...");
const singleWand = new SingleParticleWand();

// Exportar para debug
globalThis.singleWand = singleWand;